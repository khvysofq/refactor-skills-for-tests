# Skill 08: 小步重构与测试绿灯

> **触发条件**：Skill 06 或 Skill 07 完成后  
> **目标**：在护栏下推进内部重构，持续保持绿灯

---

## 输入

- 已建立的测试覆盖（单测/表征测试）
- 已引入的 Seam（如适用）

---

## 输出

| 产出 | 路径 | 必须 |
|------|------|------|
| 重构后的代码 | 原位置 | ✓ |
| 更新的测试 | `tests/` | 如需要 |
| 提交记录 | Git | ✓ |

---

## 核心原则

### 红绿循环

每次重构遵循以下循环：

| 步骤 | 动作 | 条件 |
|------|------|------|
| 1 | 确认绿灯（所有测试通过） | - |
| 2 | 做一个小改动 | - |
| 3 | 运行测试 | - |
| 4 | 检查结果 | 绿灯？是 → 提交，回到步骤 1；否 → 立即回滚或修复，回到步骤 1 |

### 小步定义

一个"小步"应该满足：
- 能在 5 分钟内完成
- 只改变一个方面
- 改变量 < 50 行（通常）
- 可以独立回滚

---

## 核心任务

### 任务 1: 确认起点绿灯

**执行**：

```bash
# 运行完整门禁
./tools/test.sh

# 确认返回 0
echo $?
```

**如果红灯**：
- 不要开始重构
- 先修复现有问题
- 或回滚到已知绿灯状态

### 任务 2: 识别重构目标

**常见重构类型**：

| 类型 | 目的 | 风险 |
|------|------|------|
| 提取函数 | 降低复杂度 | 低 |
| 提取类 | 分离职责 | 中 |
| 内联 | 消除不必要抽象 | 低 |
| 重命名 | 提高可读性 | 低 |
| 移动 | 改善结构 | 中 |
| 引入参数对象 | 简化接口 | 低 |
| 以多态取代条件 | 扩展性 | 高 |

**优先级排序**：

| 优先级 | 类型 | 说明 |
|--------|------|------|
| 1 | 低风险高收益 | 提取函数、重命名 |
| 2 | 低风险低收益 | 内联、整理 import |
| 3 | 中风险高收益 | 提取类、引入接口 |
| 4 | 高风险 | 架构调整（需要更多测试覆盖） |

### 任务 3: 执行重构循环

**每个小步的流程**：

1. 选择一个重构目标
2. 在编辑器中执行重构
3. 保存文件
4. 运行最小测试集：`./run_tests --gtest_filter="*<Module>*"`
5. 检查结果：通过 → 提交；失败 → 分析或回滚
6. 重复以上步骤

**提交消息格式**：

```
refactor(<module>): <变更描述>

- <具体改动 1>
- <具体改动 2>

[测试通过]
```

### 任务 4: 处理失败

**测试失败时的处理流程**：

| 失败类型 | 处理方式 |
|----------|----------|
| 编译错误 | 检查语法、引用，快速修复 |
| 测试逻辑失败 - 重构引入的 bug | 回滚重构，重新分析 |
| 测试逻辑失败 - 测试过度约束 | 调整测试（小心） |
| 测试逻辑失败 - 发现的真实 bug | 记录，后续 Skill 13 处理 |
| 行为变化 | 跳转到 Skill 09 |

**快速回滚**：

```bash
# 回滚未提交的更改
git checkout -- .

# 或回滚到上一个提交
git reset --hard HEAD~1
```

---

## 常见重构手法速查

### 提取函数

```cpp
// 修改前
void process() {
    // 一大段计算逻辑
    int a = x + y;
    int b = a * 2;
    int c = b - z;
    // 使用 c
}

// 修改后
int calculate(int x, int y, int z) {
    int a = x + y;
    int b = a * 2;
    return b - z;
}

void process() {
    int c = calculate(x, y, z);
    // 使用 c
}
```

### 提取类

```cpp
// 修改前
class BigClass {
    // 职责 A 的方法
    void methodA1();
    void methodA2();
    
    // 职责 B 的方法
    void methodB1();
    void methodB2();
};

// 修改后
class ResponsibilityA {
    void method1();
    void method2();
};

class RefactoredClass {
    ResponsibilityA a_;  // 委托
    
    void methodB1();
    void methodB2();
};
```

### 以查询取代临时变量

```cpp
// 修改前
void process() {
    int basePrice = quantity * itemPrice;
    if (basePrice > 1000) {
        return basePrice * 0.95;
    }
    return basePrice;
}

// 修改后
int getBasePrice() {
    return quantity * itemPrice;
}

void process() {
    if (getBasePrice() > 1000) {
        return getBasePrice() * 0.95;
    }
    return getBasePrice();
}
```

---

## 验收标准

### 必须满足

- [ ] 所有测试持续通过
- [ ] 每个重构步骤有独立提交
- [ ] 代码结构有可观察改善

### 可选指标

- [ ] 圈复杂度降低
- [ ] 函数/方法长度减少
- [ ] 类职责更单一

### 验收检查

```bash
# 所有测试通过
./tools/test.sh && echo "PASS" || echo "FAIL"

# 检查提交历史
git log --oneline -10

# 可选：检查代码复杂度
# lizard <module_path>  # 需要安装 lizard
```

---

## 应该做

- ✓ 每步之后运行测试
- ✓ 频繁提交（每 5-15 分钟）
- ✓ 保持改动小而专注
- ✓ 利用 IDE 的重构功能
- ✓ 记录重构决策

## 不应该做

- ✗ 多个重构混在一起
- ✗ 长时间不运行测试
- ✗ 在红灯状态下继续重构
- ✗ 修改测试来让失败的测试通过（除非测试确实有问题）
- ✗ 同时改变行为和结构

---

## 重构会话模板

```markdown
## 重构会话记录

### 模块: <module>
### 日期: YYYY-MM-DD

### 目标
- [ ] 提取 xxx 函数
- [ ] 重命名 yyy 为更清晰的名称
- [ ] 拆分 zzz 类

### 步骤记录

1. [✓] 提取 calculateTotal 函数
   - 提交: abc1234
   - 测试: 通过

2. [✓] 重命名 proc 为 processOrder
   - 提交: def5678
   - 测试: 通过

3. [ ] 拆分 OrderHandler...

### 问题记录
- 发现 xxx 处可能是 bug，待确认
```

---

## 状态跳转

门禁检查后，根据结果选择下一步：

| 门禁状态 | 下一步 |
|----------|--------|
| G0 Green | [Skill 11: 文档更新](skill-11-documentation.md) |
| G1 Red | 回滚或修复，重试门禁 |
| G2 Drift | [Skill 09: 行为差异判定](skill-09-behavior-drift.md) |
| G3 Flaky | [Skill 12: 稳定性治理](skill-12-stability.md) |

详细参考：[门禁失败决策](../decisions/gate-failure-decision.md)

---

## 时间预估

| 重构范围 | 预估时间 |
|----------|----------|
| 小型（几个函数） | 30 分钟 - 1 小时 |
| 中型（一个类） | 1 - 2 小时 |
| 大型（多个类交互） | 2 - 4 小时 |

---

**完成后**：运行门禁，根据结果跳转
