# 可测试性决策树

> **用途**：Skill 04 评估完成后，根据评估状态选择下一步路径  
> **触发**：完成模块可测试性评估后

---

## 决策规则总览

Skill 04 评估完成后，根据输出状态选择对应路径：

| 评估状态 | 含义 | 下一步 Skill | 后续流程 |
|----------|------|--------------|----------|
| S1 | 可直接单测 | Skill 06（直接单测） | → Skill 08 → 运行门禁 |
| S2 | 可表征 | Skill 05（表征测试） | → Skill 07 → Skill 08 → 运行门禁 |
| S3 | 需先解耦 | Skill 07（设计 Seam） | → Skill 08 → 运行门禁 |
| S4 | 需人工判定 | Skill 10（人工介入） | → 得到答案后重新评估 |

**规则**：按状态直接选择对应 Skill，完成后进入后续流程，最终汇合到运行门禁。

---

## S1: 可直接单测

### 判定条件

满足以下**全部**条件：

- [ ] 模块边界清晰
- [ ] 依赖可替换（已有接口/注入点）
- [ ] 无强副作用，或副作用可控
- [ ] 核心逻辑为纯函数或可测方法

### 典型特征

- 纯计算逻辑
- 数据转换函数
- 解析/序列化
- 状态机转换
- 已有依赖注入的类

### 下一步

执行 **Skill 06: 直接单测覆盖**（路径: skills/skill-06-unit-tests.md）

### 预期产出

- `tests/unit/<module>_test.cpp`
- 覆盖率 ≥ 70%

---

## S2: 可表征

### 判定条件

满足以下条件：

- [ ] 有明确的输入输出边界
- [ ] 行为基本确定性（或可控制非确定性）
- [ ] 可以构造稳定的测试输入集
- [ ] **但**依赖复杂，难以直接单测

### 典型特征

- 有外部依赖但边界清晰
- 行为稳定可复现
- 可以做 Golden Master 测试
- 内部实现复杂，不适合直接 mock

### 下一步

1. 执行 **Skill 05: 表征测试**（路径: skills/skill-05-characterization.md）
2. 然后执行 **Skill 07: 设计 Seam**（路径: skills/skill-07-seams.md）

### 预期产出

- `tests/characterization/<module>_golden_test.cpp`
- Golden 数据文件
- 新引入的 Seam 接口

---

## S3: 需先解耦

### 判定条件

满足以下**任一**条件：

- [ ] 无法稳定表征（行为不确定）
- [ ] 深度耦合全局状态
- [ ] 副作用难以隔离或观测
- [ ] 依赖没有抽象层且需要引入

### 典型特征

- 直接使用全局变量/单例
- 硬编码的系统调用
- 复杂的并发逻辑
- 深度嵌套的依赖

### 下一步

执行 **Skill 07: 设计 Seam 与依赖分离**（路径: skills/skill-07-seams.md）

### 预期产出

- Seam 接口定义
- 测试替身
- 可注入的依赖

### 注意事项

**重要**：如果有任何表征测试的可能，优先走 S2 路径（先有护栏再重构更安全）。

---

## S4: 需人工判定

### 判定条件

满足以下**任一**条件：

- [ ] 业务语义不清
- [ ] 行为"看起来像 bug 但可能是需求"
- [ ] 存在多种合理解释
- [ ] 缺乏文档且无法从代码确定正确性

### 典型特征

- 奇怪的边界条件处理
- 可疑的错误处理逻辑
- 未文档化的特殊行为
- 历史遗留的"魔法"代码

### 下一步

1. 执行 **Skill 10: 人工介入最小化问询**（路径: skills/skill-10-human-input.md）
2. 得到答案后：重新评估状态，返回 Skill 04

### 预期产出

- 结构化问题集
- 答案记录
- 更新的评估状态

---

## 快速决策表

| 特征 | S1 | S2 | S3 | S4 |
|------|----|----|----|----|
| 边界清晰 | ✓ | ✓ | △ | ? |
| 依赖可替换 | ✓ | △ | ✗ | - |
| 行为确定 | ✓ | ✓ | △ | ? |
| 业务语义清晰 | ✓ | ✓ | ✓ | ✗ |
| 可表征 | ✓ | ✓ | ✗ | ? |

图例：✓=是  △=部分  ✗=否  ?=不确定

---

## 边界情况处理

### S1 和 S2 边界

**问**：有一个外部依赖，但已有接口，该选 S1 还是 S2？

**答**：
- 如果替换依赖后测试有意义 → 选 S1（使用 mock）
- 如果需要真实交互才有意义 → 选 S2（表征测试）

### S2 和 S3 边界

**问**：可以做表征测试但不太稳定，该选 S2 还是 S3？

**答**：先尝试 S2 路径，如果稳定性验证失败（Skill 12），再回到 S3 先解耦。

### S3 和 S4 边界

**问**：依赖需要解耦，但不确定正确行为，该选 S3 还是 S4？

**答**：S4 优先（先搞清楚再动手）。业务不清的情况下盲目解耦风险更大。

---

## 状态流转记录

在模块卡片中记录：

```markdown
## 评估历史

| 日期 | 状态 | 理由 | 下一步 |
|------|------|------|--------|
| 01-15 | S4 | 边界条件处理不确定 | Skill 10 |
| 01-16 | S2 | 人工确认后清晰 | Skill 05 |
| 01-17 | S1 | 引入 Seam 后 | Skill 06 |
```

---

## 常见问题

### Q: 同一模块不同部分状态不同怎么办？

**A**: 拆分为多个子模块/切片分别处理：
- 核心算法部分可能是 S1
- I/O 部分可能是 S2
- 状态管理部分可能是 S3

### Q: 评估后发现状态判断错误怎么办？

**A**: 重新评估，更新状态，选择正确路径。这是正常的迭代过程，不是失败。

### Q: 多个状态条件都满足怎么选？

**A**: 按优先级选择最简单的路径：S1 > S2 > S3 > S4（能直接测就不表征，能表征就不解耦）。
